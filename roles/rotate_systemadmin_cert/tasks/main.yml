# Check KUBECONFIG is set
# Check current user/context in KUBECONFIG has access to edit apiserver/cluster and create configmaps in openshift-config ns

- name: Prepare storage
  file:
    path: "{{ item }}"
    state: directory
    mode: '0700'
  loop:
    - "{{ cert_dir }}"
    - "{{ kc_dir }}"

- name: Check access to apiserver object
  kubernetes.core.k8s_info:
    kind: apiserver
    api_version: config.openshift.io/v1
    name: cluster

- name: "Get current context"
  shell: "oc config current-context"
  register: current_context
  changed_when: false

- name: "Get the current user"
  shell: "oc config view -o jsonpath='{.contexts[?(@.name == \"{{ current_context.stdout }}\")].context.user}'"
  register: current_user
  changed_when: false

- name: "Get the current cluster"
  shell: "oc config view -o jsonpath='{.contexts[?(@.name == \"{{ current_context.stdout }}\")].context.cluster}'"
  register: current_cluster
  changed_when: false

- name: Check whether CA certificate exists
  stat:
    path: "{{ ca_crt }}"
  register: ca_certificate_exists

- name: Read existing certificate if exists
  community.crypto.x509_certificate_info:
    path: "{{ ca_crt }}"
  when: ca_certificate_exists.stat.exists
  register: ca_certificate_info

- block:
  - name: Create CA private key
    community.crypto.openssl_privatekey:
      path: "{{ ca_key }}"
  
  - name: Create certificate signing request (CSR) for CA certificate
    community.crypto.openssl_csr_pipe:
      privatekey_path: "{{ ca_key }}"
      common_name: "{{ ca_cn }}"
      organizational_unit_name: "{{ ca_ou }}"
      use_common_name_for_san: false  # since we do not specify SANs, don't use CN as a SAN
      basic_constraints:
        - 'CA:TRUE'
      basic_constraints_critical: true
      key_usage:
        - keyCertSign
      key_usage_critical: true
    register: ca_csr
  
  - name: Create self-signed CA certificate from CSR
    community.crypto.x509_certificate:
      path: "{{ ca_crt }}"
      csr_content: "{{ ca_csr.csr }}"
      privatekey_path: "{{ ca_key }}"
      provider: selfsigned

  when: not ca_certificate_exists.stat.exists or (ca_certificate_info is defined and (ca_certificate_info.subject.commonName != ca_cn or ca_certificate_info.subject.organizationalUnitName != ca_ou))

- name: Re-Read existing certificate
  community.crypto.x509_certificate_info:
    path: "{{ ca_crt }}"
  register: ca_certificate_info

- name: Assert certificate is as required
  assert:
    that:
      - "ca_certificate_info.subject.commonName == ca_cn"
      - "ca_certificate_info.subject.organizationalUnitName == ca_ou"

- name: Check whether certificate exists
  stat:
    path: "{{ kc_crt }}"
  register: certificate_exists

- name: Read existing certificate if exists
  slurp:
    src: "{{ kc_crt }}"
  when: certificate_exists.stat.exists
  register: certificate

- name: Read existing certificate if exists
  community.crypto.x509_certificate_info:
    path: "{{ kc_crt }}"
  when: certificate_exists.stat.exists
  register: certificate_info

- block:
  - name: Create private key for new certificate
    community.crypto.openssl_privatekey:
      path: "{{ kc_key }}"
  
  - name: Create certificate signing request (CSR) for new certificate
    community.crypto.openssl_csr_pipe:
      privatekey_path: "{{ kc_key }}"
      common_name: "{{ cert_user }}"
      organization_name: "{{ cert_group }}"
    register: csr
  
  - name: Sign certificate with our CA
    community.crypto.x509_certificate_pipe:
      content: "{{ (certificate.content | b64decode) if certificate_exists.stat.exists else omit }}"
      csr_content: "{{ csr.csr }}"
      provider: ownca
      ownca_path: "{{ ca_crt }}"
      ownca_privatekey_path: "{{ ca_key }}"
      ownca_not_after: "+{{ ca_validity }}d"
    register: certificate
  
  - name: Write certificate to file
    copy:
      dest: "{{ kc_crt }}"
      content: "{{ certificate.certificate }}"

  when: not certificate_exists.stat.exists or (certificate_info is defined and (certificate_info.subject.commonName != cert_user or certificate_info.subject.organizationName != cert_group))

- name: Re-Read existing certificate
  community.crypto.x509_certificate_info:
    path: "{{ kc_crt }}"
  register: certificate_info

- name: Assert certificate is as required
  assert:
    that:
      - "certificate_info.subject.commonName == cert_user"
      - "certificate_info.subject.organizationName == cert_group"

# should mandate specifying your KUBECONFIG, even if the "default" location?

- name: Validate existing kubeconfig works
  k8s_info:
    kind: Node

- name: create CA configmap
  k8s:
    definition:
      apiVersion: v1
      kind: ConfigMap
      metadata: # consider using generateName, subsequent broken reruns could overwrite this
        name: "admin-kubeconfig-client-ca-{{ ca_name }}"
        namespace: openshift-config
      data:
        ca-bundle.crt: "{{ lookup('file','{{ ca_crt }}') }}"

- name: patch the APIServer
  kubernetes.core.k8s:
    definition:
      kind: apiserver
      apiVersion: config.openshift.io/v1
      metadata:
        name: cluster
      spec:
        clientCA: 
          name: "admin-kubeconfig-client-ca-{{ ca_name }}" 
  register: apiserver

- name: Sleep for a moment to allow system to register change
  ansible.builtin.wait_for:
    timeout: 15
  when: apiserver.changed

- name: Check controller operator
  k8s_info:
    api_version: config.openshift.io/v1
    kind: ClusterOperator
    name: openshift-controller-manager
  register: co
  until: 
    - co.resources[0].status.conditions | selectattr('type','==','Progressing') | map(attribute='status') | first == 'False'
    - co.resources[0].status.conditions | selectattr('type','==','Degraded') | map(attribute='status') | first == 'False'
    - co.resources[0].status.conditions | selectattr('type','==','Available') | map(attribute='status') | first == 'True'
  retries: 30
  delay: 10

- name: "remove stale temp kubeconfig"
  file:
    state: absent
    path: "{{ kc_dir }}/kubeconfig.edit"

- name: "Backup existing kubeconfig"
  copy:
    src: "{{ lookup('ansible.builtin.env', 'KUBECONFIG') }}"
    dest: "{{ kc_dir }}/kubeconfig-backup.{{ ansible_date_time.iso8601_basic_short }}"

- name: "Create working copy of kubeconfig"
  shell: "oc config new-admin-kubeconfig >> {{ kc_dir }}/kubeconfig.edit"
      
- name: "Set certificate based user and credentials"
  shell: "oc config set-credentials '{{ cert_user }}' --client-certificate='{{ kc_crt }}' --client-key='{{ kc_key }}' --embed-certs"
  environment: 
    KUBECONFIG: "{{ kc_dir }}/kubeconfig.edit"

- name: "Update context entry for new user, certificate based credentials"
  shell: "oc config set-context admin --user='{{ cert_user }}'"
  # TODO: changed_when: conditions
  environment:
    KUBECONFIG: "{{ kc_dir }}/kubeconfig.edit"

- name: Validate new kubeconfig
  k8s_info:
    kind: Node
  environment: 
    KUBECONFIG: "{{ kc_dir }}/kubeconfig.edit"

- name: Revoke old CA by replacing it with the new one
  k8s:
    definition:
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: "admin-kubeconfig-client-ca"
        namespace: openshift-config
      data:
        ca-bundle.crt: "{{ lookup('file','{{ ca_crt }}') }}"
  when: revoke_existing
  register: revoked
  environment: 
    KUBECONFIG: "{{ kc_dir }}/kubeconfig.edit"

- name: Sleep for a moment to allow system to register change
  ansible.builtin.wait_for:
    timeout: 15
  when: revoked.changed

- name: Check controller operator
  k8s_info:
    api_version: config.openshift.io/v1
    kind: ClusterOperator
    name: openshift-controller-manager
  register: co
  until: 
    - co.resources[0].status.conditions | selectattr('type','==','Progressing') | map(attribute='status') | first == 'False'
    - co.resources[0].status.conditions | selectattr('type','==','Degraded') | map(attribute='status') | first == 'False'
    - co.resources[0].status.conditions | selectattr('type','==','Available') | map(attribute='status') | first == 'True'
  retries: 30
  delay: 10
  environment: 
    KUBECONFIG: "{{ kc_dir }}/kubeconfig.edit"

- name: remove the APIserver patch
  kubernetes.core.k8s_json_patch:
    kind: apiserver
    api_version: config.openshift.io/v1
    name: cluster
    patch:
      - op: replace
        path: /spec/clientCA
        value:: "{}"
  when: revoke_existing
  register: removed_test_ca
  environment: 
    KUBECONFIG: "{{ kc_dir }}/kubeconfig.edit"

- name: Sleep for a moment to allow system to register change
  ansible.builtin.wait_for:
    timeout: 15
  when: removed_test_ca.changed

- name: Check controller operator
  k8s_info:
    api_version: config.openshift.io/v1
    kind: ClusterOperator
    name: openshift-controller-manager
  register: co
  until: 
    - co.resources[0].status.conditions | selectattr('type','==','Progressing') | map(attribute='status') | first == 'False'
    - co.resources[0].status.conditions | selectattr('type','==','Degraded') | map(attribute='status') | first == 'False'
    - co.resources[0].status.conditions | selectattr('type','==','Available') | map(attribute='status') | first == 'True'
  retries: 30
  delay: 10
  environment: 
    KUBECONFIG: "{{ kc_dir }}/kubeconfig.edit"

- name: remove the additional configmap
  k8s:
    kind: ConfigMap
    name: "admin-kubeconfig-client-ca-{{ ca_name }}"
    namespace: openshift-config
    state: absent
  when: revoke_existing
  environment: 
    KUBECONFIG: "{{ kc_dir }}/kubeconfig.edit"

- name: Validate existing kubeconfig now fails
  k8s_info:
    kind: apiServer
  register: get_apiserver
  failed_when: get_apiserver.resources is defined

- name: "Create new kubeconfig"
  copy:
    src: "{{ kc_dir }}/kubeconfig.edit"
    dest: "{{ kc_dir }}/kubeconfig.new"

- name: "remove temp kubeconfig"
  file:
    state: absent
    path: "{{ kc_dir }}/kubeconfig.edit"
